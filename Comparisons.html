<!DOCTYPE html>

<html lang="en">
<head>
<!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
<meta charset="utf-8"/>
<title>Comparisons — Panel 0.9.6 documentation</title>
<meta content="High-level dashboarding for python visualization libraries" name="description"/>
<meta content="Panel contributors" name="author"/>
<!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<!-- FONT
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
<script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.16/webfont.js"></script>
<script>
    WebFont.load({
      google: {
        families: ['Source Sans Pro']
      }
    });
  </script>
<!-- CSS
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
<link href="_static/css/main.css" rel="stylesheet"/>
<link href="_static/nbsite.css" rel="stylesheet"/>
<link href="_static/site.css" rel="stylesheet"/>
<!-- Scripts
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
<script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script async="" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript">
</script>
<script src="_static/js/main.js"></script>
<!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
<link href="_static/favicon.ico" rel="icon" type="image/png"/>
<!-- Canonical
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
<link href="https://panel.holoviz.org/Comparisons.html" rel="canonical">
</link></head>
<body class="">
<header class="navigation">
<div class="wrapper">
<a class="logo" href="index.html">
<img alt="Logo" src="_static/logo_horizontal.png"/>
</a>
<a class="navigation-menu-button" href="javascript:void(0)" id="js-mobile-menu">Menu</a>
<nav>
<ul class="navigation-menu show" id="js-navigation-menu">
<li class="nav-link doc-head"><a href="//discourse.holoviz.org">Discourse</a></li>
<li class="nav-link doc-head"><a href="//twitter.com/Panel_org">Twitter</a></li>
<li class="nav-link doc-head"><a href="//github.com/pyviz/panel">Github</a></li>
<li class="nav-link">
<div style="display:inline-block;vertical-align: middle;">
<div class="search-bar">
<form action="search.html" method="get" role="search">
<input name="q" placeholder="Search" type="search"/>
<button type="submit">
<img alt="Search Icon" src="https://raw.githubusercontent.com/thoughtbot/refills/master/source/images/search-icon-black.png"/>
</button>
</form>
</div>
</div>
</li>
</ul>
</nav>
</div>
</header>
<div class="second-nav">
<nav>
<ul class="navigation-menu show">
<li class="nav-link doc-head"><a href="getting_started/index.html">Getting started</a></li>
<li class="nav-link doc-head"><a href="user_guide/index.html">User Guide</a></li>
<li class="nav-link doc-head"><a href="gallery/index.html">Gallery</a></li>
<li class="nav-link doc-head"><a href="reference/index.html">Reference Gallery</a></li>
<li class="nav-link doc-head"><a href="developer_guide/index.html">Developer Guide</a></li>
<li class="nav-link doc-head"><a href="releases.html">Releases</a></li>
<li class="nav-link doc-head"><a href="api/index.html">API</a></li>
<li class="nav-link doc-head"><a href="FAQ.html">FAQ</a></li>
<li class="nav-link doc-head"><a href="about.html">About</a></li>
</ul>
</nav>
</div>
<!-- MAIN BODY OF DOCS –––––––––––––––––– -->
<div class="docs section">
<div id="hacketyhackhack"> <!-- style="width:20%;margin-right: 100px;"> --> <!--style="display: none;"> style="display:none;"> -->
<div class="toc" style="width:15%; margin-right:20px;">
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started/index.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="user_guide/index.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="gallery/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference/index.html">Reference Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="developer_guide/index.html">Developer Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="api/index.html">API</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Comparisons</a></li>
<li class="toctree-l1"><a class="reference internal" href="releases.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="Roadmap.html">Road Map</a></li>
<li class="toctree-l1"><a class="reference internal" href="FAQ.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference external" href="http://github.com/pyviz/panel">Github source</a></li>
<li class="toctree-l1"><a class="reference internal" href="about.html">About</a></li>
</ul>
</div>
</div>
<div class="content"> <!-- style="max-width:80%;margin-left:auto;margin-right: auto;">-->
<div class="section" id="comparisons">
<h1>Comparisons<a class="headerlink" href="#comparisons" title="Permalink to this headline">¶</a></h1>
<div class="section" id="comparing-panel-and-bokeh">
<h2>Comparing Panel and Bokeh<a class="headerlink" href="#comparing-panel-and-bokeh" title="Permalink to this headline">¶</a></h2>
<p>Panel and Bokeh can both be used to create dashboards in Python, but are intended for different uses and different audiences:</p>
<ul class="simple">
<li><p>Panel is based on the internal layout and server components of Bokeh, while adding full bidirectional communication support for usage in Jupyter, making the same code fully usable in both notebook and server contexts so that it need not be rewritten for different purposes.</p></li>
<li><p>Panel does not depend on any of Bokeh’s plotting, and it can be used equally well with plots from a very wide variety of sources. To use such plots with Bokeh directly would require significant custom coding.</p></li>
<li><p>Bokeh focuses on providing lower-level primitives that can be used to create any dashboard with enough effort, while Panel focuses on making common data-science tasks and making typical types of apps easier.</p></li>
</ul>
</div>
<div class="section" id="comparing-panel-and-dash">
<h2>Comparing Panel and Dash<a class="headerlink" href="#comparing-panel-and-dash" title="Permalink to this headline">¶</a></h2>
<p>Panel and Dash can both be used to create dashboards in Python, but take very different approaches:</p>
<ul class="simple">
<li><p>Panel provides full, seamless support for usage in Jupyter notebooks, making it simple to add controls and layouts wherever they are needed in a workflow, without necessarily building up to any particular shareable app. Dash is focused almost exclusively on standalone dashboards, though there are some workarounds available for using Dash in notebooks.</p></li>
<li><p>Panel focuses on helping Python users create apps and dashboards using Python, with a concise and expressive Pythonic syntax. Dash reveals more of the underlying HTML and CSS details, which is useful for customization but can be distracting during the data-exploration phase of a project.</p></li>
<li><p>Panel is plotting-library agnostic, fully supporting a wide range of Python libraries out of the box, including Plotly. Dash has full support for Plotly but only limited support for other plotting libraries, using separate extension packages.</p></li>
<li><p>Dash dashboards store all of their per-user session state in the client (i.e., the browser), while Panel allows per-user, per-session state in both the server and the client, synchronizing between the two if needed. This difference has important implications:</p>
<ul>
<li><p>Dash’s approach is more highly scalable in some cases, allowing many simultaneous client sessions without necessarily using up resources on the server for each new client.</p></li>
<li><p>Dash’s approach requires dashboards to be written only in a reactive way, with logic defined by Python callback functions that have no side effects; imperative functions that change Python-based state are not supported. Panel supports server-side caching of intermediate results and other state per user, which can make complex processing pipelines that need server-side data much more practical. For instance, both approaches can generate and update Datashader plots as a user pans and zooms, using large datasets stored only on the server, but they will work in very different ways. With Dash, all requests will need to start with the original dataset and do all the processing steps needed to fill a client request, returning the final plot rendered for the client to show, because no intermediate data will be stored on the server for a subsequent call to use. With Panel, it is possible to write apps that re-run only the very specific computations needed for a specific request, making use of previously computed intermediate values stored per user and per session on the server and never communicated to the client. The <a class="reference external" href="https://examples.pyviz.org/datashader_dashboard/dashboard.html">Datashader example dashboard</a> shows how to use this intermediate-value caching to provide the fastest possible updates for a given user action, only re-running the computation actually needed to satisfy the request, re-using cached values stored on the server when appropriate.</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="comparing-panel-and-ipywidgets">
<h2>Comparing Panel and ipywidgets<a class="headerlink" href="#comparing-panel-and-ipywidgets" title="Permalink to this headline">¶</a></h2>
<p>Both Panel and ipywidgets (aka Jupyter Widgets) allow Python users to work with custom widgets and create apps and dashboards from Python, both in Jupyter notebooks and in standalone servers (when paired with Voila). But Panel and ipywidgets are based on different, independently developed technologies for doing so, with some implications:</p>
<ul class="simple">
<li><p>Panel is based on Bokeh widgets, which were developed separately from the Jupyter ecosystem, and designed from the start for standalone deployments. Jupyter widgets, as the name suggests, were first developed specifically for the notebook environment, and only relatively recently (in 2019) adapted for standalone deployment (see Voila, below). Nowadays, both technologies have evolved to be well suited to both Jupyter and server contexts, but their different histories are still visible in the types of examples you typically see and in support for less-common operations for each library.</p></li>
<li><p>ipywidgets expose more of the underlying HTML/CSS styling options, allowing them to be customized more heavily than Bokeh widgets currently allow.</p></li>
<li><p>Panel widgets support easy embedding into static HTML pages for exporting notebooks, while ipywidgets require a separate and cumbersome <a class="reference external" href="https://ipywidgets.readthedocs.io/en/latest/embedding.html">“embed widget state”</a> operation to copy state from Python into the web page source. Panel widgets are thus easier to use for HTML reports, documentation (e.g. with Sphinx), and other cases where the output needs to be readable or usable without a running Python process.</p></li>
<li><p>Where appropriate, Panel supports separating your scientific/engineering/business logic from your GUI implementation, allowing you to declare information that is used to make widgets in a way that is independent of any particular GUI toolkit, web packages, browser, or any other fast-changing technology. Specifically, Panel widgets build on the <a class="reference external" href="https://param.pyviz.org">Param</a> library that allows capturing the arguments and parameters of functions and classes independently of how the user may later provide or adjust those values. Param lets you specify the name, type, docstring, and range of valid values in a generic way that has no dependencies on any GUI library (or any other library) and allows validating user input in general, not just for a specific dashboard app. Once the parameters have been declared, the code can be used for command-line applications, servers, batch jobs, or (with Panel) generating live, active widgets automatically with no further customization needed to build an app. Param has been in continuous use by multiple libraries since 2003, across many generations of GUI toolkits, and can be expected to adapt to future toolkits as they become available without needing changes to your own domain-specific codebase. Panel can thus integrate into a large, long-lived codebase that is used in a variety of different ways at any one time or over its lifetime, such as a simulator or modeling tool, domain-specific analysis libraries, automated processing pipelines, and so on, without ever needing the code to be rewritten or having the GUI code drift out of sync with the business/scientific logic. ipywidgets are designed for the final application or dashboard usage, not for this full life cycle of research or analysis code.</p></li>
<li><p>Panel widgets are reactive, allowing declarative specification of dependencies between code and widgets (or, more specifically, between code and the Param parameter values inside the widgets). This approach makes it possible to support directly accepting widget objects as arguments to Python code. That way, users never have to write explicit Python callbacks, yet the code will dynamically be executed as needed to respond to user interaction. This programming paradigm can provide highly responsive GUI applications with much less code and much simpler reasoning, as illustrated in the <a class="reference external" href="https://anaconda.org/jbednar/dashboard_barewidgets/notebook">Datashader widget dashboard</a>.</p></li>
</ul>
</div>
<div class="section" id="comparing-panel-and-voila">
<h2>Comparing Panel and Voila<a class="headerlink" href="#comparing-panel-and-voila" title="Permalink to this headline">¶</a></h2>
<p>Voila is a technology for deploying Jupyter notebooks (with or without Panel code) as standalone web pages backed by Python. Voila is thus one way you can deploy your Panel apps, your ipywidgets-based apps, or any other content visible in a Jupyter notebook (including multiple languages, like R or C++). Voila is an alternative to the Bokeh Server component that is available through <code class="docutils literal notranslate"><span class="pre">panel</span> <span class="pre">serve</span></code>; Panel works with either one, and you can deploy with <em>either</em> Bokeh Server (panel serve) or Voila.</p>
<p>So, how do you choose between using Voila or Bokeh server?  First, at present (10/2019), Voila is the only way to deploy a Python-backed app that contains both Bokeh-based components (including Panel objects) and ipywidgets-based components. So, if you want to deploy apps that contain ipyvolume, ipyleaflet, or bqplot components, you’ll need Voila for serving, but you can also include any Panel object you wish, as long as you wrap it as an ipywidget using support from the optional <a class="reference external" href="https://github.com/bokeh/jupyter_bokeh">jupyter_bokeh</a> package. As long as you have <code class="docutils literal notranslate"><span class="pre">jupyter_bokeh</span></code> availabke, just do <code class="docutils literal notranslate"><span class="pre">pn.ipywidget(panel_obj)</span></code> and you can then use that Panel object as an ipywidget in Voila (or Jupyter itself).</p>
<p>If you don’t need ipywidget support, you can use either Bokeh Server or Voila for serving Panel objects. Which one should you choose?  Both servers are based on Tornado under the hood, but they differ in the fact that Jupyter will launch a new Python kernel for each user, while the Bokeh server can serve multiple users on the same process. This subtle difference has two major implications:</p>
<ol class="arabic simple">
<li><p>The per-user overhead for a Bokeh app is much lower. Once the relevant libraries are imported, there is only a tiny bit of overhead for creating each new session. The Jupyter server, on the other hand, always launches an entirely new process, with all the overhead that entails. For a session that imports nothing but pandas and matplotlib the per-user overhead is 75 MB (as of 10/2019), which increases for more complex environments.</p></li>
<li><p>Since a Bokeh server shares a single process for multiple sessions, data or processing can also be shared between the different sessions where appropriate. Such sharing makes it possible to further reduce the memory footprint of a Bokeh-Server app, to make it practical to support larger numbers of users and to provide faster startup or data-access times.</p></li>
</ol>
<p>The other major difference between Bokeh Server and Voila is the way they process notebook files. Voila is built directly on the notebook format, though it also provides some support for bare Python files. By default, all output in the notebook (including Markdown cells) is included in the rendered Voila app, which has the benefit that existing notebooks can be served as apps <em>unchanged</em>. While that approach can be useful to get a quick set of plots, an existing notebook is unlikely to be organized and formatted in a way that forms a coherent dashboard, so in practice a notebook will need to be rewritten (suppressing markdown and some outputs, rearranging other cell outputs, etc.) before it will make a good Voila dashboard. In practice, you will then end up with two copies of the notebook: one optimized to be a narrative, storytelling notebook with a series of cells, and another organized as a dashboard. Or you can write a template to select only the cells you want in the dashboard and rearrange them, but then you need to maintain both the notebook and the template separately.</p>
<p>Panel takes a different approach, in that output from a notebook cell needs to be explicitly wrapped in a Panel object and marked as being “servable”; cell outputs and Markdown cells by default are shown only in the notebook, and not with <code class="docutils literal notranslate"><span class="pre">panel</span> <span class="pre">serve</span></code>. Panel in fact entirely ignores the fact that your notebook is organized into cells; it simply processes all the cells as Python code, and serves all the items that ended up being marked “servable”. Although this approach means editing the original notebook before you can see a dashboard, it makes it fully practical for the same notebook to serve both an exploratory or storytelling purpose (in Jupyter) and act as a dashboard deployment (of a designated subset of the functionality). The Panel developers very often use this functionality to provide detailed documentation for any given panel, with the cell-by-cell output showing the dataset, intermediate steps, interesting features, and how-tos, while the final deployed dashboard focuses on the final result.</p>
</div>
<div class="section" id="comparing-panel-and-streamlit">
<h2>Comparing Panel and streamlit<a class="headerlink" href="#comparing-panel-and-streamlit" title="Permalink to this headline">¶</a></h2>
<p>streamlit is an alternative to all of the above packages. Like Jupyter, streamlit provides an interactive, incremental way to build apps. streamlit works with Python text files written in a separate editor, while Jupyter uses a web-based notebook cell editor. Although a web-based editor makes it simple to work locally on remote files, using a local Python text file allows users to maximize their productivity by choosing their own favorite editor. Dash, Panel, and Bokeh all also support bare Python files developed in a local editor, and like streamlit they can all also watch that file and automatically re-run the file when you change it in the editor (e.g. for Panel or Bokeh, launch <code class="docutils literal notranslate"><span class="pre">bokeh</span> <span class="pre">serve</span> <span class="pre">file.py</span> <span class="pre">--dev</span></code> to watch the Python file and re-launch the served app on any changes).</p>
<p>Streamlit’s key difference from those other tools is that with streamlit, the entire Python source file is effectively re-run <em>every time a widget changes value</em>, which has the advantage of not allowing confusing out-of-order execution of notebook cells, and also can make it simpler to reason about state in general. However, for this approach to be practical, it requires all lengthy computations to be made cacheable, which is not always straightforward and can introduce its own highly complicated reasoning about state. Moreover, the streamlit approach has similar downsides as for Dash’s lack of server-side state, in that it becomes difficult to generate responsive apps for complex situations that need a precise mapping between a widget event and a specific small bit of Python code. Panel thus has better support for fully reactive applications, where each widget or component of a plot is explicitly and specifically tied to a bit of computation, re-running only the tiniest bit of code that is needed for that particular action.</p>
<p>Another major difference is that Panel, in contrast to streamlit, fully supports Jupyter notebooks, for when you wish to preserve a series of text/code/output steps as an exploratory record, whether to document a workflow for later reproducibility, to tell a story about data, or for any other approach where having individual outputs per cell is useful. Thus Panel does not require you to make a binary switch between “exploring some data” or “telling a story” and “developing an app”; it simply lets you use widgets and layouts whenever they are useful or appropriate, without ever having a cost to switch between such activities. Of course, Panel does not <em>require</em> Jupyter, but because it supports Jupyter fully it is usable in a wide range of situations for which streamlit is not designed.</p>
<p>Overall, Panel can be used in a much wider range of applications than streamlit, including exploratory data analysis and capturing a reproducible workflow in a Jupyter notebook, developing a simple streamlit-like app, or developing complex, multi-page responsive apps, all without having to switch frameworks or learn a new set of tools. Panel thus supports the entire life cycle of data science, engineering, or scientific artifacts, not just a narrow task of developing a specific type of simple app.</p>
</div>
</div>
</div>
</div>
<!-- END MAIN BODY OF DOCS ––––––––––––– -->
<!-- Google Analytics -->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-154795830-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-154795830-2');
</script>
<!-- MathJax Config -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>
<!-- End Document
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
</body>
</html>