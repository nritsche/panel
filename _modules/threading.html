<!DOCTYPE html>

<html lang="en">
<head>
<!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
<meta charset="utf-8"/>
<title>threading — Panel 0.9.6 documentation</title>
<meta content="High-level dashboarding for python visualization libraries" name="description"/>
<meta content="Panel contributors" name="author"/>
<!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<!-- FONT
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
<script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.16/webfont.js"></script>
<script>
    WebFont.load({
      google: {
        families: ['Source Sans Pro']
      }
    });
  </script>
<!-- CSS
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
<link href="../_static/css/main.css" rel="stylesheet"/>
<link href="../_static/nbsite.css" rel="stylesheet"/>
<link href="../_static/site.css" rel="stylesheet"/>
<!-- Scripts
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
<script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script async="" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript">
</script>
<script src="../_static/js/main.js"></script>
<!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
<link href="../_static/favicon.ico" rel="icon" type="image/png"/>
<!-- Canonical
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
<link href="https://panel.holoviz.org/_modules/threading.html" rel="canonical">
</link></head>
<body class="">
<header class="navigation">
<div class="wrapper">
<a class="logo" href="../index.html">
<img alt="Logo" src="../_static/logo_horizontal.png"/>
</a>
<a class="navigation-menu-button" href="javascript:void(0)" id="js-mobile-menu">Menu</a>
<nav>
<ul class="navigation-menu show" id="js-navigation-menu">
<li class="nav-link doc-head"><a href="//discourse.holoviz.org">Discourse</a></li>
<li class="nav-link doc-head"><a href="//twitter.com/Panel_org">Twitter</a></li>
<li class="nav-link doc-head"><a href="//github.com/pyviz/panel">Github</a></li>
<li class="nav-link">
<div style="display:inline-block;vertical-align: middle;">
<div class="search-bar">
<form action="../search.html" method="get" role="search">
<input name="q" placeholder="Search" type="search"/>
<button type="submit">
<img alt="Search Icon" src="https://raw.githubusercontent.com/thoughtbot/refills/master/source/images/search-icon-black.png"/>
</button>
</form>
</div>
</div>
</li>
</ul>
</nav>
</div>
</header>
<div class="second-nav">
<nav>
<ul class="navigation-menu show">
<li class="nav-link doc-head"><a href="../getting_started/index.html">Getting started</a></li>
<li class="nav-link doc-head"><a href="../user_guide/index.html">User Guide</a></li>
<li class="nav-link doc-head"><a href="../gallery/index.html">Gallery</a></li>
<li class="nav-link doc-head"><a href="../reference/index.html">Reference Gallery</a></li>
<li class="nav-link doc-head"><a href="../developer_guide/index.html">Developer Guide</a></li>
<li class="nav-link doc-head"><a href="../releases.html">Releases</a></li>
<li class="nav-link doc-head"><a href="../api/index.html">API</a></li>
<li class="nav-link doc-head"><a href="../FAQ.html">FAQ</a></li>
<li class="nav-link doc-head"><a href="../about.html">About</a></li>
</ul>
</nav>
</div>
<!-- MAIN BODY OF DOCS –––––––––––––––––– -->
<div class="docs section">
<div id="hacketyhackhack"> <!-- style="width:20%;margin-right: 100px;"> --> <!--style="display: none;"> style="display:none;"> -->
<div class="toc" style="width:15%; margin-right:20px;">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/index.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide/index.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gallery/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">Reference Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developer_guide/index.html">Developer Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/index.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Comparisons.html">Comparisons</a></li>
<li class="toctree-l1"><a class="reference internal" href="../releases.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Roadmap.html">Road Map</a></li>
<li class="toctree-l1"><a class="reference internal" href="../FAQ.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference external" href="http://github.com/pyviz/panel">Github source</a></li>
<li class="toctree-l1"><a class="reference internal" href="../about.html">About</a></li>
</ul>
</div>
</div>
<div class="content"> <!-- style="max-width:80%;margin-left:auto;margin-right: auto;">-->
<h1>Source code for threading</h1><div class="highlight"><pre>
<span></span><span class="sd">"""Thread module emulating a subset of Java's threading model."""</span>

<span class="kn">import</span> <span class="nn">os</span> <span class="k">as</span> <span class="nn">_os</span>
<span class="kn">import</span> <span class="nn">sys</span> <span class="k">as</span> <span class="nn">_sys</span>
<span class="kn">import</span> <span class="nn">_thread</span>

<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">monotonic</span> <span class="k">as</span> <span class="n">_time</span>
<span class="kn">from</span> <span class="nn">traceback</span> <span class="kn">import</span> <span class="n">format_exc</span> <span class="k">as</span> <span class="n">_format_exc</span>
<span class="kn">from</span> <span class="nn">_weakrefset</span> <span class="kn">import</span> <span class="n">WeakSet</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">islice</span> <span class="k">as</span> <span class="n">_islice</span><span class="p">,</span> <span class="n">count</span> <span class="k">as</span> <span class="n">_count</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">_collections</span> <span class="kn">import</span> <span class="n">deque</span> <span class="k">as</span> <span class="n">_deque</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span> <span class="k">as</span> <span class="n">_deque</span>

<span class="c1"># Note regarding PEP 8 compliant names</span>
<span class="c1">#  This threading model was originally inspired by Java, and inherited</span>
<span class="c1"># the convention of camelCase function and method names from that</span>
<span class="c1"># language. Those original names are not in any imminent danger of</span>
<span class="c1"># being deprecated (even for Py3k),so this module provides them as an</span>
<span class="c1"># alias for the PEP 8 compliant names</span>
<span class="c1"># Note that using the new PEP 8 compliant names facilitates substitution</span>
<span class="c1"># with the multiprocessing module, which doesn't provide the old</span>
<span class="c1"># Java inspired names.</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'get_ident'</span><span class="p">,</span> <span class="s1">'active_count'</span><span class="p">,</span> <span class="s1">'Condition'</span><span class="p">,</span> <span class="s1">'current_thread'</span><span class="p">,</span>
           <span class="s1">'enumerate'</span><span class="p">,</span> <span class="s1">'main_thread'</span><span class="p">,</span> <span class="s1">'TIMEOUT_MAX'</span><span class="p">,</span>
           <span class="s1">'Event'</span><span class="p">,</span> <span class="s1">'Lock'</span><span class="p">,</span> <span class="s1">'RLock'</span><span class="p">,</span> <span class="s1">'Semaphore'</span><span class="p">,</span> <span class="s1">'BoundedSemaphore'</span><span class="p">,</span> <span class="s1">'Thread'</span><span class="p">,</span>
           <span class="s1">'Barrier'</span><span class="p">,</span> <span class="s1">'BrokenBarrierError'</span><span class="p">,</span> <span class="s1">'Timer'</span><span class="p">,</span> <span class="s1">'ThreadError'</span><span class="p">,</span>
           <span class="s1">'setprofile'</span><span class="p">,</span> <span class="s1">'settrace'</span><span class="p">,</span> <span class="s1">'local'</span><span class="p">,</span> <span class="s1">'stack_size'</span><span class="p">]</span>

<span class="c1"># Rename some stuff so "from threading import *" is safe</span>
<span class="n">_start_new_thread</span> <span class="o">=</span> <span class="n">_thread</span><span class="o">.</span><span class="n">start_new_thread</span>
<span class="n">_allocate_lock</span> <span class="o">=</span> <span class="n">_thread</span><span class="o">.</span><span class="n">allocate_lock</span>
<span class="n">_set_sentinel</span> <span class="o">=</span> <span class="n">_thread</span><span class="o">.</span><span class="n">_set_sentinel</span>
<span class="n">get_ident</span> <span class="o">=</span> <span class="n">_thread</span><span class="o">.</span><span class="n">get_ident</span>
<span class="n">ThreadError</span> <span class="o">=</span> <span class="n">_thread</span><span class="o">.</span><span class="n">error</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">_CRLock</span> <span class="o">=</span> <span class="n">_thread</span><span class="o">.</span><span class="n">RLock</span>
<span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
    <span class="n">_CRLock</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">TIMEOUT_MAX</span> <span class="o">=</span> <span class="n">_thread</span><span class="o">.</span><span class="n">TIMEOUT_MAX</span>
<span class="k">del</span> <span class="n">_thread</span>


<span class="c1"># Support for profile and trace hooks</span>

<span class="n">_profile_hook</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">_trace_hook</span> <span class="o">=</span> <span class="kc">None</span>

<span class="k">def</span> <span class="nf">setprofile</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">"""Set a profile function for all threads started from the threading module.</span>

<span class="sd">    The func will be passed to sys.setprofile() for each thread, before its</span>
<span class="sd">    run() method is called.</span>

<span class="sd">    """</span>
    <span class="k">global</span> <span class="n">_profile_hook</span>
    <span class="n">_profile_hook</span> <span class="o">=</span> <span class="n">func</span>

<span class="k">def</span> <span class="nf">settrace</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">"""Set a trace function for all threads started from the threading module.</span>

<span class="sd">    The func will be passed to sys.settrace() for each thread, before its run()</span>
<span class="sd">    method is called.</span>

<span class="sd">    """</span>
    <span class="k">global</span> <span class="n">_trace_hook</span>
    <span class="n">_trace_hook</span> <span class="o">=</span> <span class="n">func</span>

<span class="c1"># Synchronization classes</span>

<span class="n">Lock</span> <span class="o">=</span> <span class="n">_allocate_lock</span>

<span class="k">def</span> <span class="nf">RLock</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">"""Factory function that returns a new reentrant lock.</span>

<span class="sd">    A reentrant lock must be released by the thread that acquired it. Once a</span>
<span class="sd">    thread has acquired a reentrant lock, the same thread may acquire it again</span>
<span class="sd">    without blocking; the thread must release it once for each time it has</span>
<span class="sd">    acquired it.</span>

<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">_CRLock</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_PyRLock</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_CRLock</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">_RLock</span><span class="p">:</span>
    <span class="sd">"""This class implements reentrant lock objects.</span>

<span class="sd">    A reentrant lock must be released by the thread that acquired it. Once a</span>
<span class="sd">    thread has acquired a reentrant lock, the same thread may acquire it</span>
<span class="sd">    again without blocking; the thread must release it once for each time it</span>
<span class="sd">    has acquired it.</span>

<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_block</span> <span class="o">=</span> <span class="n">_allocate_lock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_owner</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">owner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owner</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">owner</span> <span class="o">=</span> <span class="n">_active</span><span class="p">[</span><span class="n">owner</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="s2">"&lt;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2"> object owner=</span><span class="si">%r</span><span class="s2"> count=</span><span class="si">%d</span><span class="s2"> at </span><span class="si">%s</span><span class="s2">&gt;"</span> <span class="o">%</span> <span class="p">(</span>
            <span class="s2">"locked"</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_block</span><span class="o">.</span><span class="n">locked</span><span class="p">()</span> <span class="k">else</span> <span class="s2">"unlocked"</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__qualname__</span><span class="p">,</span>
            <span class="n">owner</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_count</span><span class="p">,</span>
            <span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blocking</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">"""Acquire a lock, blocking or non-blocking.</span>

<span class="sd">        When invoked without arguments: if this thread already owns the lock,</span>
<span class="sd">        increment the recursion level by one, and return immediately. Otherwise,</span>
<span class="sd">        if another thread owns the lock, block until the lock is unlocked. Once</span>
<span class="sd">        the lock is unlocked (not owned by any thread), then grab ownership, set</span>
<span class="sd">        the recursion level to one, and return. If more than one thread is</span>
<span class="sd">        blocked waiting until the lock is unlocked, only one at a time will be</span>
<span class="sd">        able to grab ownership of the lock. There is no return value in this</span>
<span class="sd">        case.</span>

<span class="sd">        When invoked with the blocking argument set to true, do the same thing</span>
<span class="sd">        as when called without arguments, and return true.</span>

<span class="sd">        When invoked with the blocking argument set to false, do not block. If a</span>
<span class="sd">        call without an argument would block, return false immediately;</span>
<span class="sd">        otherwise, do the same thing as when called without arguments, and</span>
<span class="sd">        return true.</span>

<span class="sd">        When invoked with the floating-point timeout argument set to a positive</span>
<span class="sd">        value, block for at most the number of seconds specified by timeout</span>
<span class="sd">        and as long as the lock cannot be acquired.  Return true if the lock has</span>
<span class="sd">        been acquired, false if the timeout has elapsed.</span>

<span class="sd">        """</span>
        <span class="n">me</span> <span class="o">=</span> <span class="n">get_ident</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owner</span> <span class="o">==</span> <span class="n">me</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="n">rc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_block</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">blocking</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rc</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_owner</span> <span class="o">=</span> <span class="n">me</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">rc</span>

    <span class="fm">__enter__</span> <span class="o">=</span> <span class="n">acquire</span>

    <span class="k">def</span> <span class="nf">release</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Release a lock, decrementing the recursion level.</span>

<span class="sd">        If after the decrement it is zero, reset the lock to unlocked (not owned</span>
<span class="sd">        by any thread), and if any other threads are blocked waiting for the</span>
<span class="sd">        lock to become unlocked, allow exactly one of them to proceed. If after</span>
<span class="sd">        the decrement the recursion level is still nonzero, the lock remains</span>
<span class="sd">        locked and owned by the calling thread.</span>

<span class="sd">        Only call this method when the calling thread owns the lock. A</span>
<span class="sd">        RuntimeError is raised if this method is called when the lock is</span>
<span class="sd">        unlocked.</span>

<span class="sd">        There is no return value.</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owner</span> <span class="o">!=</span> <span class="n">get_ident</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"cannot release un-acquired lock"</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">count</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_owner</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_block</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

    <span class="c1"># Internal methods used by condition variables</span>

    <span class="k">def</span> <span class="nf">_acquire_restore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_block</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_count</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owner</span> <span class="o">=</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">_release_save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"cannot release un-acquired lock"</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">owner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owner</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_owner</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_block</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">owner</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_is_owned</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owner</span> <span class="o">==</span> <span class="n">get_ident</span><span class="p">()</span>

<span class="n">_PyRLock</span> <span class="o">=</span> <span class="n">_RLock</span>


<span class="k">class</span> <span class="nc">Condition</span><span class="p">:</span>
    <span class="sd">"""Class that implements a condition variable.</span>

<span class="sd">    A condition variable allows one or more threads to wait until they are</span>
<span class="sd">    notified by another thread.</span>

<span class="sd">    If the lock argument is given and not None, it must be a Lock or RLock</span>
<span class="sd">    object, and it is used as the underlying lock. Otherwise, a new RLock object</span>
<span class="sd">    is created and used as the underlying lock.</span>

<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">lock</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lock</span> <span class="o">=</span> <span class="n">RLock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span> <span class="o">=</span> <span class="n">lock</span>
        <span class="c1"># Export the lock's acquire() and release() methods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acquire</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="n">acquire</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="n">release</span>
        <span class="c1"># If the lock defines _release_save() and/or _acquire_restore(),</span>
        <span class="c1"># these override the default implementations (which just call</span>
        <span class="c1"># release() and acquire() on the lock).  Ditto for _is_owned().</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_release_save</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="n">_release_save</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_acquire_restore</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="n">_acquire_restore</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_owned</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="n">_is_owned</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_waiters</span> <span class="o">=</span> <span class="n">_deque</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="o">.</span><span class="fm">__enter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="o">.</span><span class="fm">__exit__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">"&lt;Condition(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%d</span><span class="s2">)&gt;"</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_waiters</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_release_save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>           <span class="c1"># No state to save</span>

    <span class="k">def</span> <span class="nf">_acquire_restore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>           <span class="c1"># Ignore saved state</span>

    <span class="k">def</span> <span class="nf">_is_owned</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Return True if lock is owned by current_thread.</span>
        <span class="c1"># This method is called only if _lock doesn't have _is_owned().</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""Wait until notified or until a timeout occurs.</span>

<span class="sd">        If the calling thread has not acquired the lock when this method is</span>
<span class="sd">        called, a RuntimeError is raised.</span>

<span class="sd">        This method releases the underlying lock, and then blocks until it is</span>
<span class="sd">        awakened by a notify() or notify_all() call for the same condition</span>
<span class="sd">        variable in another thread, or until the optional timeout occurs. Once</span>
<span class="sd">        awakened or timed out, it re-acquires the lock and returns.</span>

<span class="sd">        When the timeout argument is present and not None, it should be a</span>
<span class="sd">        floating point number specifying a timeout for the operation in seconds</span>
<span class="sd">        (or fractions thereof).</span>

<span class="sd">        When the underlying lock is an RLock, it is not released using its</span>
<span class="sd">        release() method, since this may not actually unlock the lock when it</span>
<span class="sd">        was acquired multiple times recursively. Instead, an internal interface</span>
<span class="sd">        of the RLock class is used, which really unlocks it even when it has</span>
<span class="sd">        been recursively acquired several times. Another internal interface is</span>
<span class="sd">        then used to restore the recursion level when the lock is reacquired.</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_owned</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"cannot wait on un-acquired lock"</span><span class="p">)</span>
        <span class="n">waiter</span> <span class="o">=</span> <span class="n">_allocate_lock</span><span class="p">()</span>
        <span class="n">waiter</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_waiters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">waiter</span><span class="p">)</span>
        <span class="n">saved_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_release_save</span><span class="p">()</span>
        <span class="n">gotit</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">try</span><span class="p">:</span>    <span class="c1"># restore state no matter what (e.g., KeyboardInterrupt)</span>
            <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">waiter</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
                <span class="n">gotit</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">timeout</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">gotit</span> <span class="o">=</span> <span class="n">waiter</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">gotit</span> <span class="o">=</span> <span class="n">waiter</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">gotit</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_acquire_restore</span><span class="p">(</span><span class="n">saved_state</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">gotit</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_waiters</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">waiter</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">wait_for</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""Wait until a condition evaluates to True.</span>

<span class="sd">        predicate should be a callable which result will be interpreted as a</span>
<span class="sd">        boolean value.  A timeout may be provided giving the maximum time to</span>
<span class="sd">        wait.</span>

<span class="sd">        """</span>
        <span class="n">endtime</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">waittime</span> <span class="o">=</span> <span class="n">timeout</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">predicate</span><span class="p">()</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">waittime</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">endtime</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">endtime</span> <span class="o">=</span> <span class="n">_time</span><span class="p">()</span> <span class="o">+</span> <span class="n">waittime</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">waittime</span> <span class="o">=</span> <span class="n">endtime</span> <span class="o">-</span> <span class="n">_time</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">waittime</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">break</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">waittime</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">predicate</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">notify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">"""Wake up one or more threads waiting on this condition, if any.</span>

<span class="sd">        If the calling thread has not acquired the lock when this method is</span>
<span class="sd">        called, a RuntimeError is raised.</span>

<span class="sd">        This method wakes up at most n of the threads waiting for the condition</span>
<span class="sd">        variable; it is a no-op if no threads are waiting.</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_owned</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"cannot notify on un-acquired lock"</span><span class="p">)</span>
        <span class="n">all_waiters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_waiters</span>
        <span class="n">waiters_to_notify</span> <span class="o">=</span> <span class="n">_deque</span><span class="p">(</span><span class="n">_islice</span><span class="p">(</span><span class="n">all_waiters</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">waiters_to_notify</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">waiter</span> <span class="ow">in</span> <span class="n">waiters_to_notify</span><span class="p">:</span>
            <span class="n">waiter</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">all_waiters</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">waiter</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">notify_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Wake up all threads waiting on this condition.</span>

<span class="sd">        If the calling thread has not acquired the lock when this method</span>
<span class="sd">        is called, a RuntimeError is raised.</span>

<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_waiters</span><span class="p">))</span>

    <span class="n">notifyAll</span> <span class="o">=</span> <span class="n">notify_all</span>


<span class="k">class</span> <span class="nc">Semaphore</span><span class="p">:</span>
    <span class="sd">"""This class implements semaphore objects.</span>

<span class="sd">    Semaphores manage a counter representing the number of release() calls minus</span>
<span class="sd">    the number of acquire() calls, plus an initial value. The acquire() method</span>
<span class="sd">    blocks if necessary until it can return without making the counter</span>
<span class="sd">    negative. If not given, value defaults to 1.</span>

<span class="sd">    """</span>

    <span class="c1"># After Tim Peters' semaphore class, but not quite the same (no maximum)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"semaphore initial value must be &gt;= 0"</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cond</span> <span class="o">=</span> <span class="n">Condition</span><span class="p">(</span><span class="n">Lock</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blocking</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""Acquire a semaphore, decrementing the internal counter by one.</span>

<span class="sd">        When invoked without arguments: if the internal counter is larger than</span>
<span class="sd">        zero on entry, decrement it by one and return immediately. If it is zero</span>
<span class="sd">        on entry, block, waiting until some other thread has called release() to</span>
<span class="sd">        make it larger than zero. This is done with proper interlocking so that</span>
<span class="sd">        if multiple acquire() calls are blocked, release() will wake exactly one</span>
<span class="sd">        of them up. The implementation may pick one at random, so the order in</span>
<span class="sd">        which blocked threads are awakened should not be relied on. There is no</span>
<span class="sd">        return value in this case.</span>

<span class="sd">        When invoked with blocking set to true, do the same thing as when called</span>
<span class="sd">        without arguments, and return true.</span>

<span class="sd">        When invoked with blocking set to false, do not block. If a call without</span>
<span class="sd">        an argument would block, return false immediately; otherwise, do the</span>
<span class="sd">        same thing as when called without arguments, and return true.</span>

<span class="sd">        When invoked with a timeout other than None, it will block for at</span>
<span class="sd">        most timeout seconds.  If acquire does not complete successfully in</span>
<span class="sd">        that interval, return false.  Return true otherwise.</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">blocking</span> <span class="ow">and</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"can't specify timeout for non-blocking acquire"</span><span class="p">)</span>
        <span class="n">rc</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">endtime</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cond</span><span class="p">:</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">blocking</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">endtime</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">endtime</span> <span class="o">=</span> <span class="n">_time</span><span class="p">()</span> <span class="o">+</span> <span class="n">timeout</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">timeout</span> <span class="o">=</span> <span class="n">endtime</span> <span class="o">-</span> <span class="n">_time</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">timeout</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">break</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cond</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">rc</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">rc</span>

    <span class="fm">__enter__</span> <span class="o">=</span> <span class="n">acquire</span>

    <span class="k">def</span> <span class="nf">release</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Release a semaphore, incrementing the internal counter by one.</span>

<span class="sd">        When the counter is zero on entry and another thread is waiting for it</span>
<span class="sd">        to become larger than zero again, wake up that thread.</span>

<span class="sd">        """</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cond</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cond</span><span class="o">.</span><span class="n">notify</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">BoundedSemaphore</span><span class="p">(</span><span class="n">Semaphore</span><span class="p">):</span>
    <span class="sd">"""Implements a bounded semaphore.</span>

<span class="sd">    A bounded semaphore checks to make sure its current value doesn't exceed its</span>
<span class="sd">    initial value. If it does, ValueError is raised. In most situations</span>
<span class="sd">    semaphores are used to guard resources with limited capacity.</span>

<span class="sd">    If the semaphore is released too many times it's a sign of a bug. If not</span>
<span class="sd">    given, value defaults to 1.</span>

<span class="sd">    Like regular semaphores, bounded semaphores manage a counter representing</span>
<span class="sd">    the number of release() calls minus the number of acquire() calls, plus an</span>
<span class="sd">    initial value. The acquire() method blocks if necessary until it can return</span>
<span class="sd">    without making the counter negative. If not given, value defaults to 1.</span>

<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">Semaphore</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initial_value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">release</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Release a semaphore, incrementing the internal counter by one.</span>

<span class="sd">        When the counter is zero on entry and another thread is waiting for it</span>
<span class="sd">        to become larger than zero again, wake up that thread.</span>

<span class="sd">        If the number of releases exceeds the number of acquires,</span>
<span class="sd">        raise a ValueError.</span>

<span class="sd">        """</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cond</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_value</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Semaphore released too many times"</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cond</span><span class="o">.</span><span class="n">notify</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">Event</span><span class="p">:</span>
    <span class="sd">"""Class implementing event objects.</span>

<span class="sd">    Events manage a flag that can be set to true with the set() method and reset</span>
<span class="sd">    to false with the clear() method. The wait() method blocks until the flag is</span>
<span class="sd">    true.  The flag is initially false.</span>

<span class="sd">    """</span>

    <span class="c1"># After Tim Peters' event class (without is_posted())</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cond</span> <span class="o">=</span> <span class="n">Condition</span><span class="p">(</span><span class="n">Lock</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flag</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_reset_internal_locks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># private!  called by Thread._reset_internal_locks by _after_fork()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cond</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">Lock</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">is_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Return true if and only if the internal flag is true."""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flag</span>

    <span class="n">isSet</span> <span class="o">=</span> <span class="n">is_set</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Set the internal flag to true.</span>

<span class="sd">        All threads waiting for it to become true are awakened. Threads</span>
<span class="sd">        that call wait() once the flag is true will not block at all.</span>

<span class="sd">        """</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cond</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flag</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cond</span><span class="o">.</span><span class="n">notify_all</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Reset the internal flag to false.</span>

<span class="sd">        Subsequently, threads calling wait() will block until set() is called to</span>
<span class="sd">        set the internal flag to true again.</span>

<span class="sd">        """</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cond</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flag</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""Block until the internal flag is true.</span>

<span class="sd">        If the internal flag is true on entry, return immediately. Otherwise,</span>
<span class="sd">        block until another thread calls set() to set the flag to true, or until</span>
<span class="sd">        the optional timeout occurs.</span>

<span class="sd">        When the timeout argument is present and not None, it should be a</span>
<span class="sd">        floating point number specifying a timeout for the operation in seconds</span>
<span class="sd">        (or fractions thereof).</span>

<span class="sd">        This method returns the internal flag on exit, so it will always return</span>
<span class="sd">        True except if a timeout is given and the operation times out.</span>

<span class="sd">        """</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cond</span><span class="p">:</span>
            <span class="n">signaled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flag</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">signaled</span><span class="p">:</span>
                <span class="n">signaled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cond</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">signaled</span>


<span class="c1"># A barrier class.  Inspired in part by the pthread_barrier_* api and</span>
<span class="c1"># the CyclicBarrier class from Java.  See</span>
<span class="c1"># http://sourceware.org/pthreads-win32/manual/pthread_barrier_init.html and</span>
<span class="c1"># http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/</span>
<span class="c1">#        CyclicBarrier.html</span>
<span class="c1"># for information.</span>
<span class="c1"># We maintain two main states, 'filling' and 'draining' enabling the barrier</span>
<span class="c1"># to be cyclic.  Threads are not allowed into it until it has fully drained</span>
<span class="c1"># since the previous cycle.  In addition, a 'resetting' state exists which is</span>
<span class="c1"># similar to 'draining' except that threads leave with a BrokenBarrierError,</span>
<span class="c1"># and a 'broken' state in which all threads get the exception.</span>
<span class="k">class</span> <span class="nc">Barrier</span><span class="p">:</span>
    <span class="sd">"""Implements a Barrier.</span>

<span class="sd">    Useful for synchronizing a fixed number of threads at known synchronization</span>
<span class="sd">    points.  Threads block on 'wait()' and are simultaneously awoken once they</span>
<span class="sd">    have all made that call.</span>

<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parties</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""Create a barrier, initialised to 'parties' threads.</span>

<span class="sd">        'action' is a callable which, when supplied, will be called by one of</span>
<span class="sd">        the threads after they have all entered the barrier and just prior to</span>
<span class="sd">        releasing them all. If a 'timeout' is provided, it is used as the</span>
<span class="sd">        default for all subsequent 'wait()' calls.</span>

<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cond</span> <span class="o">=</span> <span class="n">Condition</span><span class="p">(</span><span class="n">Lock</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_action</span> <span class="o">=</span> <span class="n">action</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_timeout</span> <span class="o">=</span> <span class="n">timeout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parties</span> <span class="o">=</span> <span class="n">parties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">#0 filling, 1, draining, -1 resetting, -2 broken</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""Wait for the barrier.</span>

<span class="sd">        When the specified number of threads have started waiting, they are all</span>
<span class="sd">        simultaneously awoken. If an 'action' was provided for the barrier, one</span>
<span class="sd">        of the threads will have executed that callback prior to returning.</span>
<span class="sd">        Returns an individual index number from 0 to 'parties-1'.</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">timeout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timeout</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cond</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_enter</span><span class="p">()</span> <span class="c1"># Block while the barrier drains.</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parties</span><span class="p">:</span>
                    <span class="c1"># We release the barrier</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_release</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># We wait until someone releases us</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_wait</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">index</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="c1"># Wake up any threads waiting for barrier to drain.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_exit</span><span class="p">()</span>

    <span class="c1"># Block until the barrier is ready for us, or raise an exception</span>
    <span class="c1"># if it is broken.</span>
    <span class="k">def</span> <span class="nf">_enter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="ow">in</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># It is draining or resetting, wait until done</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cond</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
        <span class="c1">#see if the barrier is in a broken state</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">BrokenBarrierError</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="c1"># Optionally run the 'action' and release the threads waiting</span>
    <span class="c1"># in the barrier.</span>
    <span class="k">def</span> <span class="nf">_release</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_action</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_action</span><span class="p">()</span>
            <span class="c1"># enter draining state</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cond</span><span class="o">.</span><span class="n">notify_all</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="c1">#an exception during the _action handler.  Break and reraise</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_break</span><span class="p">()</span>
            <span class="k">raise</span>

    <span class="c1"># Wait in the barrier until we are released.  Raise an exception</span>
    <span class="c1"># if the barrier is reset or broken.</span>
    <span class="k">def</span> <span class="nf">_wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cond</span><span class="o">.</span><span class="n">wait_for</span><span class="p">(</span><span class="k">lambda</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">timeout</span><span class="p">):</span>
            <span class="c1">#timed out.  Break the barrier</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_break</span><span class="p">()</span>
            <span class="k">raise</span> <span class="n">BrokenBarrierError</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">BrokenBarrierError</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="c1"># If we are the last thread to exit the barrier, signal any threads</span>
    <span class="c1"># waiting for the barrier to drain.</span>
    <span class="k">def</span> <span class="nf">_exit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="ow">in</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c1">#resetting or draining</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cond</span><span class="o">.</span><span class="n">notify_all</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Reset the barrier to the initial state.</span>

<span class="sd">        Any threads currently waiting will get the BrokenBarrier exception</span>
<span class="sd">        raised.</span>

<span class="sd">        """</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cond</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1">#reset the barrier, waking up threads</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                    <span class="c1">#was broken, set it to reset state</span>
                    <span class="c1">#which clears when the last thread exits</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cond</span><span class="o">.</span><span class="n">notify_all</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">abort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Place the barrier into a 'broken' state.</span>

<span class="sd">        Useful in case of error.  Any currently waiting threads and threads</span>
<span class="sd">        attempting to 'wait()' will have BrokenBarrierError raised.</span>

<span class="sd">        """</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cond</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_break</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_break</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># An internal error was detected.  The barrier is set to</span>
        <span class="c1"># a broken state all parties awakened.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cond</span><span class="o">.</span><span class="n">notify_all</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Return the number of threads required to trip the barrier."""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parties</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_waiting</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Return the number of threads currently waiting at the barrier."""</span>
        <span class="c1"># We don't need synchronization here since this is an ephemeral result</span>
        <span class="c1"># anyway.  It returns the correct value in the steady state.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">broken</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Return True if the barrier is in a broken state."""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span>

<span class="c1"># exception raised by the Barrier class</span>
<span class="k">class</span> <span class="nc">BrokenBarrierError</span><span class="p">(</span><span class="ne">RuntimeError</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="c1"># Helper to generate new thread names</span>
<span class="n">_counter</span> <span class="o">=</span> <span class="n">_count</span><span class="p">()</span><span class="o">.</span><span class="fm">__next__</span>
<span class="n">_counter</span><span class="p">()</span> <span class="c1"># Consume 0 so first non-main thread has id 1.</span>
<span class="k">def</span> <span class="nf">_newname</span><span class="p">(</span><span class="n">template</span><span class="o">=</span><span class="s2">"Thread-</span><span class="si">%d</span><span class="s2">"</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">template</span> <span class="o">%</span> <span class="n">_counter</span><span class="p">()</span>

<span class="c1"># Active thread administration</span>
<span class="n">_active_limbo_lock</span> <span class="o">=</span> <span class="n">_allocate_lock</span><span class="p">()</span>
<span class="n">_active</span> <span class="o">=</span> <span class="p">{}</span>    <span class="c1"># maps thread id to Thread object</span>
<span class="n">_limbo</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">_dangling</span> <span class="o">=</span> <span class="n">WeakSet</span><span class="p">()</span>
<span class="c1"># Set of Thread._tstate_lock locks of non-daemon threads used by _shutdown()</span>
<span class="c1"># to wait until all Python thread states get deleted:</span>
<span class="c1"># see Thread._set_tstate_lock().</span>
<span class="n">_shutdown_locks_lock</span> <span class="o">=</span> <span class="n">_allocate_lock</span><span class="p">()</span>
<span class="n">_shutdown_locks</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

<span class="c1"># Main class for threads</span>

<span class="k">class</span> <span class="nc">Thread</span><span class="p">:</span>
    <span class="sd">"""A class that represents a thread of control.</span>

<span class="sd">    This class can be safely subclassed in a limited fashion. There are two ways</span>
<span class="sd">    to specify the activity: by passing a callable object to the constructor, or</span>
<span class="sd">    by overriding the run() method in a subclass.</span>

<span class="sd">    """</span>

    <span class="n">_initialized</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># Need to store a reference to sys.exc_info for printing</span>
    <span class="c1"># out exceptions when a thread tries to use a global var. during interp.</span>
    <span class="c1"># shutdown and thus raises an exception about trying to perform some</span>
    <span class="c1"># operation on/with a NoneType</span>
    <span class="n">_exc_info</span> <span class="o">=</span> <span class="n">_sys</span><span class="o">.</span><span class="n">exc_info</span>
    <span class="c1"># Keep sys.exc_clear too to clear the exception just before</span>
    <span class="c1"># allowing .join() to return.</span>
    <span class="c1">#XXX __exc_clear = _sys.exc_clear</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""This constructor should always be called with keyword arguments. Arguments are:</span>

<span class="sd">        *group* should be None; reserved for future extension when a ThreadGroup</span>
<span class="sd">        class is implemented.</span>

<span class="sd">        *target* is the callable object to be invoked by the run()</span>
<span class="sd">        method. Defaults to None, meaning nothing is called.</span>

<span class="sd">        *name* is the thread name. By default, a unique name is constructed of</span>
<span class="sd">        the form "Thread-N" where N is a small decimal number.</span>

<span class="sd">        *args* is the argument tuple for the target invocation. Defaults to ().</span>

<span class="sd">        *kwargs* is a dictionary of keyword arguments for the target</span>
<span class="sd">        invocation. Defaults to {}.</span>

<span class="sd">        If a subclass overrides the constructor, it must make sure to invoke</span>
<span class="sd">        the base class constructor (Thread.__init__()) before doing anything</span>
<span class="sd">        else to the thread.</span>

<span class="sd">        """</span>
        <span class="k">assert</span> <span class="n">group</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">"group argument must be None for now"</span>
        <span class="k">if</span> <span class="n">kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_target</span> <span class="o">=</span> <span class="n">target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span> <span class="ow">or</span> <span class="n">_newname</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>
        <span class="k">if</span> <span class="n">daemon</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_daemonic</span> <span class="o">=</span> <span class="n">daemon</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_daemonic</span> <span class="o">=</span> <span class="n">current_thread</span><span class="p">()</span><span class="o">.</span><span class="n">daemon</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ident</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tstate_lock</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_started</span> <span class="o">=</span> <span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_stopped</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># sys.stderr is not stored in the class like</span>
        <span class="c1"># sys.exc_info since it can be changed between instances</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stderr</span> <span class="o">=</span> <span class="n">_sys</span><span class="o">.</span><span class="n">stderr</span>
        <span class="c1"># For debugging and _after_fork()</span>
        <span class="n">_dangling</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reset_internal_locks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_alive</span><span class="p">):</span>
        <span class="c1"># private!  Called by _after_fork() to reset our internal locks as</span>
        <span class="c1"># they may be in an invalid state leading to a deadlock or crash.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_started</span><span class="o">.</span><span class="n">_reset_internal_locks</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">is_alive</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_tstate_lock</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The thread isn't alive after fork: it doesn't have a tstate</span>
            <span class="c1"># anymore.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_stopped</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tstate_lock</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span><span class="p">,</span> <span class="s2">"Thread.__init__() was not called"</span>
        <span class="n">status</span> <span class="o">=</span> <span class="s2">"initial"</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_started</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="n">status</span> <span class="o">=</span> <span class="s2">"started"</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_alive</span><span class="p">()</span> <span class="c1"># easy way to get ._is_stopped set when appropriate</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_stopped</span><span class="p">:</span>
            <span class="n">status</span> <span class="o">=</span> <span class="s2">"stopped"</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_daemonic</span><span class="p">:</span>
            <span class="n">status</span> <span class="o">+=</span> <span class="s2">" daemon"</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ident</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">status</span> <span class="o">+=</span> <span class="s2">" </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ident</span>
        <span class="k">return</span> <span class="s2">"&lt;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">)&gt;"</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Start the thread's activity.</span>

<span class="sd">        It must be called at most once per thread object. It arranges for the</span>
<span class="sd">        object's run() method to be invoked in a separate thread of control.</span>

<span class="sd">        This method will raise a RuntimeError if called more than once on the</span>
<span class="sd">        same thread object.</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"thread.__init__() not called"</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_started</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"threads can only be started once"</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
            <span class="n">_limbo</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_start_new_thread</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bootstrap</span><span class="p">,</span> <span class="p">())</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">_limbo</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>
            <span class="k">raise</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_started</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Method representing the thread's activity.</span>

<span class="sd">        You may override this method in a subclass. The standard run() method</span>
<span class="sd">        invokes the callable object passed to the object's constructor as the</span>
<span class="sd">        target argument, if any, with sequential and keyword arguments taken</span>
<span class="sd">        from the args and kwargs arguments, respectively.</span>

<span class="sd">        """</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_target</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c1"># Avoid a refcycle if the thread is running a function with</span>
            <span class="c1"># an argument that has a member that points to the thread.</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span>

    <span class="k">def</span> <span class="nf">_bootstrap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Wrapper around the real bootstrap code that ignores</span>
        <span class="c1"># exceptions during interpreter cleanup.  Those typically</span>
        <span class="c1"># happen when a daemon thread wakes up at an unfortunate</span>
        <span class="c1"># moment, finds the world around it destroyed, and raises some</span>
        <span class="c1"># random exception *** while trying to report the exception in</span>
        <span class="c1"># _bootstrap_inner() below ***.  Those random exceptions</span>
        <span class="c1"># don't help anybody, and they confuse users, so we suppress</span>
        <span class="c1"># them.  We suppress them only when it appears that the world</span>
        <span class="c1"># indeed has already been destroyed, so that exceptions in</span>
        <span class="c1"># _bootstrap_inner() during normal business hours are properly</span>
        <span class="c1"># reported.  Also, we only suppress them for daemonic threads;</span>
        <span class="c1"># if a non-daemonic encounters this, something else is wrong.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bootstrap_inner</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_daemonic</span> <span class="ow">and</span> <span class="n">_sys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">raise</span>

    <span class="k">def</span> <span class="nf">_set_ident</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ident</span> <span class="o">=</span> <span class="n">get_ident</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_set_tstate_lock</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set a lock object which will be released by the interpreter when</span>
<span class="sd">        the underlying thread state (see pystate.h) gets deleted.</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tstate_lock</span> <span class="o">=</span> <span class="n">_set_sentinel</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tstate_lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">daemon</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">_shutdown_locks_lock</span><span class="p">:</span>
                <span class="n">_shutdown_locks</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tstate_lock</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_bootstrap_inner</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_ident</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_tstate_lock</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_started</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
            <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
                <span class="n">_active</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_ident</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
                <span class="k">del</span> <span class="n">_limbo</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">_trace_hook</span><span class="p">:</span>
                <span class="n">_sys</span><span class="o">.</span><span class="n">settrace</span><span class="p">(</span><span class="n">_trace_hook</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_profile_hook</span><span class="p">:</span>
                <span class="n">_sys</span><span class="o">.</span><span class="n">setprofile</span><span class="p">(</span><span class="n">_profile_hook</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">SystemExit</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="c1"># If sys.stderr is no more (most likely from interpreter</span>
                <span class="c1"># shutdown) use self._stderr.  Otherwise still use sys (as in</span>
                <span class="c1"># _sys) in case sys.stderr was redefined since the creation of</span>
                <span class="c1"># self.</span>
                <span class="k">if</span> <span class="n">_sys</span> <span class="ow">and</span> <span class="n">_sys</span><span class="o">.</span><span class="n">stderr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">"Exception in thread </span><span class="si">%s</span><span class="s2">:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span>
                          <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">_format_exc</span><span class="p">()),</span> <span class="n">file</span><span class="o">=</span><span class="n">_sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stderr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Do the best job possible w/o a huge amt. of code to</span>
                    <span class="c1"># approximate a traceback (code ideas from</span>
                    <span class="c1"># Lib/traceback.py)</span>
                    <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">exc_tb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exc_info</span><span class="p">()</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">((</span>
                            <span class="s2">"Exception in thread "</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span>
                            <span class="s2">" (most likely raised during interpreter shutdown):"</span><span class="p">),</span> <span class="n">file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_stderr</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">((</span>
                            <span class="s2">"Traceback (most recent call last):"</span><span class="p">),</span> <span class="n">file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_stderr</span><span class="p">)</span>
                        <span class="k">while</span> <span class="n">exc_tb</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">((</span>
                                <span class="s1">'  File "</span><span class="si">%s</span><span class="s1">", line </span><span class="si">%s</span><span class="s1">, in </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span>
                                <span class="p">(</span><span class="n">exc_tb</span><span class="o">.</span><span class="n">tb_frame</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_filename</span><span class="p">,</span>
                                    <span class="n">exc_tb</span><span class="o">.</span><span class="n">tb_lineno</span><span class="p">,</span>
                                    <span class="n">exc_tb</span><span class="o">.</span><span class="n">tb_frame</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span><span class="p">)),</span> <span class="n">file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_stderr</span><span class="p">)</span>
                            <span class="n">exc_tb</span> <span class="o">=</span> <span class="n">exc_tb</span><span class="o">.</span><span class="n">tb_next</span>
                        <span class="nb">print</span><span class="p">((</span><span class="s2">"</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="p">(</span><span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">)),</span> <span class="n">file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_stderr</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_stderr</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
                    <span class="c1"># Make sure that exc_tb gets deleted since it is a memory</span>
                    <span class="c1"># hog; deleting everything else is just for thoroughness</span>
                    <span class="k">finally</span><span class="p">:</span>
                        <span class="k">del</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">exc_tb</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="c1"># Prevent a race in</span>
                <span class="c1"># test_threading.test_no_refcycle_through_target when</span>
                <span class="c1"># the exception keeps the target alive past when we</span>
                <span class="c1"># assert that it's dead.</span>
                <span class="c1">#XXX self._exc_clear()</span>
                <span class="k">pass</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># We don't call self._delete() because it also</span>
                    <span class="c1"># grabs _active_limbo_lock.</span>
                    <span class="k">del</span> <span class="n">_active</span><span class="p">[</span><span class="n">get_ident</span><span class="p">()]</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_stop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># After calling ._stop(), .is_alive() returns False and .join() returns</span>
        <span class="c1"># immediately.  ._tstate_lock must be released before calling ._stop().</span>
        <span class="c1">#</span>
        <span class="c1"># Normal case:  C code at the end of the thread's life</span>
        <span class="c1"># (release_sentinel in _threadmodule.c) releases ._tstate_lock, and</span>
        <span class="c1"># that's detected by our ._wait_for_tstate_lock(), called by .join()</span>
        <span class="c1"># and .is_alive().  Any number of threads _may_ call ._stop()</span>
        <span class="c1"># simultaneously (for example, if multiple threads are blocked in</span>
        <span class="c1"># .join() calls), and they're not serialized.  That's harmless -</span>
        <span class="c1"># they'll just make redundant rebindings of ._is_stopped and</span>
        <span class="c1"># ._tstate_lock.  Obscure:  we rebind ._tstate_lock last so that the</span>
        <span class="c1"># "assert self._is_stopped" in ._wait_for_tstate_lock() always works</span>
        <span class="c1"># (the assert is executed only if ._tstate_lock is None).</span>
        <span class="c1">#</span>
        <span class="c1"># Special case:  _main_thread releases ._tstate_lock via this</span>
        <span class="c1"># module's _shutdown() function.</span>
        <span class="n">lock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tstate_lock</span>
        <span class="k">if</span> <span class="n">lock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">lock</span><span class="o">.</span><span class="n">locked</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_stopped</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tstate_lock</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">daemon</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">_shutdown_locks_lock</span><span class="p">:</span>
                <span class="n">_shutdown_locks</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">lock</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">"Remove current thread from the dict of currently running threads."</span>
        <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">_active</span><span class="p">[</span><span class="n">get_ident</span><span class="p">()]</span>
            <span class="c1"># There must not be any python code between the previous line</span>
            <span class="c1"># and after the lock is released.  Otherwise a tracing function</span>
            <span class="c1"># could try to acquire the lock again in the same thread, (in</span>
            <span class="c1"># current_thread()), and would block.</span>

    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""Wait until the thread terminates.</span>

<span class="sd">        This blocks the calling thread until the thread whose join() method is</span>
<span class="sd">        called terminates -- either normally or through an unhandled exception</span>
<span class="sd">        or until the optional timeout occurs.</span>

<span class="sd">        When the timeout argument is present and not None, it should be a</span>
<span class="sd">        floating point number specifying a timeout for the operation in seconds</span>
<span class="sd">        (or fractions thereof). As join() always returns None, you must call</span>
<span class="sd">        is_alive() after join() to decide whether a timeout happened -- if the</span>
<span class="sd">        thread is still alive, the join() call timed out.</span>

<span class="sd">        When the timeout argument is not present or None, the operation will</span>
<span class="sd">        block until the thread terminates.</span>

<span class="sd">        A thread can be join()ed many times.</span>

<span class="sd">        join() raises a RuntimeError if an attempt is made to join the current</span>
<span class="sd">        thread as that would cause a deadlock. It is also an error to join() a</span>
<span class="sd">        thread before it has been started and attempts to do so raises the same</span>
<span class="sd">        exception.</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"Thread.__init__() not called"</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_started</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"cannot join thread before it is started"</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">current_thread</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"cannot join current thread"</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wait_for_tstate_lock</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># the behavior of a negative timeout isn't documented, but</span>
            <span class="c1"># historically .join(timeout=x) for x&lt;0 has acted as if timeout=0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wait_for_tstate_lock</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_wait_for_tstate_lock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Issue #18808: wait for the thread state to be gone.</span>
        <span class="c1"># At the end of the thread's life, after all knowledge of the thread</span>
        <span class="c1"># is removed from C data structures, C code releases our _tstate_lock.</span>
        <span class="c1"># This method passes its arguments to _tstate_lock.acquire().</span>
        <span class="c1"># If the lock is acquired, the C code is done, and self._stop() is</span>
        <span class="c1"># called.  That sets ._is_stopped to True, and ._tstate_lock to None.</span>
        <span class="n">lock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tstate_lock</span>
        <span class="k">if</span> <span class="n">lock</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># already determined that the C code is done</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_stopped</span>
        <span class="k">elif</span> <span class="n">lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">timeout</span><span class="p">):</span>
            <span class="n">lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stop</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""A string used for identification purposes only.</span>

<span class="sd">        It has no semantics. Multiple threads may be given the same name. The</span>
<span class="sd">        initial name is set by the constructor.</span>

<span class="sd">        """</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span><span class="p">,</span> <span class="s2">"Thread.__init__() not called"</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@name</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span><span class="p">,</span> <span class="s2">"Thread.__init__() not called"</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ident</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Thread identifier of this thread or None if it has not been started.</span>

<span class="sd">        This is a nonzero integer. See the get_ident() function. Thread</span>
<span class="sd">        identifiers may be recycled when a thread exits and another thread is</span>
<span class="sd">        created. The identifier is available even after the thread has exited.</span>

<span class="sd">        """</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span><span class="p">,</span> <span class="s2">"Thread.__init__() not called"</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ident</span>

    <span class="k">def</span> <span class="nf">is_alive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Return whether the thread is alive.</span>

<span class="sd">        This method returns True just before the run() method starts until just</span>
<span class="sd">        after the run() method terminates. The module function enumerate()</span>
<span class="sd">        returns a list of all alive threads.</span>

<span class="sd">        """</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span><span class="p">,</span> <span class="s2">"Thread.__init__() not called"</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_stopped</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_started</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wait_for_tstate_lock</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_stopped</span>

    <span class="k">def</span> <span class="nf">isAlive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Return whether the thread is alive.</span>

<span class="sd">        This method is deprecated, use is_alive() instead.</span>
<span class="sd">        """</span>
        <span class="kn">import</span> <span class="nn">warnings</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">'isAlive() is deprecated, use is_alive() instead'</span><span class="p">,</span>
                      <span class="ne">PendingDeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_alive</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">daemon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""A boolean value indicating whether this thread is a daemon thread.</span>

<span class="sd">        This must be set before start() is called, otherwise RuntimeError is</span>
<span class="sd">        raised. Its initial value is inherited from the creating thread; the</span>
<span class="sd">        main thread is not a daemon thread and therefore all threads created in</span>
<span class="sd">        the main thread default to daemon = False.</span>

<span class="sd">        The entire Python program exits when only daemon threads are left.</span>

<span class="sd">        """</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span><span class="p">,</span> <span class="s2">"Thread.__init__() not called"</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_daemonic</span>

    <span class="nd">@daemon</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">daemon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">daemonic</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"Thread.__init__() not called"</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_started</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"cannot set daemon status of active thread"</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_daemonic</span> <span class="o">=</span> <span class="n">daemonic</span>

    <span class="k">def</span> <span class="nf">isDaemon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">daemon</span>

    <span class="k">def</span> <span class="nf">setDaemon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">daemonic</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="n">daemonic</span>

    <span class="k">def</span> <span class="nf">getName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">setName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

<span class="c1"># The timer class was contributed by Itamar Shtull-Trauring</span>

<span class="k">class</span> <span class="nc">Timer</span><span class="p">(</span><span class="n">Thread</span><span class="p">):</span>
    <span class="sd">"""Call a function after a specified number of seconds:</span>

<span class="sd">            t = Timer(30.0, f, args=None, kwargs=None)</span>
<span class="sd">            t.start()</span>
<span class="sd">            t.cancel()     # stop the timer's action if it's still waiting</span>

<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">Thread</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interval</span> <span class="o">=</span> <span class="n">interval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span> <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span> <span class="k">if</span> <span class="n">kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finished</span> <span class="o">=</span> <span class="n">Event</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Stop the timer if it hasn't finished yet."""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finished</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finished</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interval</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">finished</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finished</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>


<span class="c1"># Special thread class to represent the main thread</span>

<span class="k">class</span> <span class="nc">_MainThread</span><span class="p">(</span><span class="n">Thread</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Thread</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">"MainThread"</span><span class="p">,</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_tstate_lock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_started</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_ident</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
            <span class="n">_active</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_ident</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>


<span class="c1"># Dummy thread class to represent threads not started here.</span>
<span class="c1"># These aren't garbage collected when they die, nor can they be waited for.</span>
<span class="c1"># If they invoke anything in threading.py that calls current_thread(), they</span>
<span class="c1"># leave an entry in the _active dict forever after.</span>
<span class="c1"># Their purpose is to return *something* from current_thread().</span>
<span class="c1"># They are marked as daemon threads so we won't wait for them</span>
<span class="c1"># when we exit (conform previous semantics).</span>

<span class="k">class</span> <span class="nc">_DummyThread</span><span class="p">(</span><span class="n">Thread</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Thread</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">_newname</span><span class="p">(</span><span class="s2">"Dummy-</span><span class="si">%d</span><span class="s2">"</span><span class="p">),</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_started</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_ident</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
            <span class="n">_active</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_ident</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_stop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">is_alive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_stopped</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_started</span><span class="o">.</span><span class="n">is_set</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">"cannot join a dummy thread"</span>


<span class="c1"># Global API functions</span>

<span class="k">def</span> <span class="nf">current_thread</span><span class="p">():</span>
    <span class="sd">"""Return the current Thread object, corresponding to the caller's thread of control.</span>

<span class="sd">    If the caller's thread of control was not created through the threading</span>
<span class="sd">    module, a dummy thread object with limited functionality is returned.</span>

<span class="sd">    """</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_active</span><span class="p">[</span><span class="n">get_ident</span><span class="p">()]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_DummyThread</span><span class="p">()</span>

<span class="n">currentThread</span> <span class="o">=</span> <span class="n">current_thread</span>

<span class="k">def</span> <span class="nf">active_count</span><span class="p">():</span>
    <span class="sd">"""Return the number of Thread objects currently alive.</span>

<span class="sd">    The returned count is equal to the length of the list returned by</span>
<span class="sd">    enumerate().</span>

<span class="sd">    """</span>
    <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">_active</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">_limbo</span><span class="p">)</span>

<span class="n">activeCount</span> <span class="o">=</span> <span class="n">active_count</span>

<span class="k">def</span> <span class="nf">_enumerate</span><span class="p">():</span>
    <span class="c1"># Same as enumerate(), but without the lock. Internal use only.</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">_active</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">_limbo</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">enumerate</span><span class="p">():</span>
    <span class="sd">"""Return a list of all Thread objects currently alive.</span>

<span class="sd">    The list includes daemonic threads, dummy thread objects created by</span>
<span class="sd">    current_thread(), and the main thread. It excludes terminated threads and</span>
<span class="sd">    threads that have not yet been started.</span>

<span class="sd">    """</span>
    <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">_active</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">_limbo</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

<span class="kn">from</span> <span class="nn">_thread</span> <span class="kn">import</span> <span class="n">stack_size</span>

<span class="c1"># Create the main thread object,</span>
<span class="c1"># and make it available for the interpreter</span>
<span class="c1"># (Py_Main) as threading._shutdown.</span>

<span class="n">_main_thread</span> <span class="o">=</span> <span class="n">_MainThread</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">_shutdown</span><span class="p">():</span>
    <span class="sd">"""</span>
<span class="sd">    Wait until the Python thread state of all non-daemon threads get deleted.</span>
<span class="sd">    """</span>
    <span class="c1"># Obscure:  other threads may be waiting to join _main_thread.  That's</span>
    <span class="c1"># dubious, but some code does it.  We can't wait for C code to release</span>
    <span class="c1"># the main thread's tstate_lock - that won't happen until the interpreter</span>
    <span class="c1"># is nearly dead.  So we release it here.  Note that just calling _stop()</span>
    <span class="c1"># isn't enough:  other threads may already be waiting on _tstate_lock.</span>
    <span class="k">if</span> <span class="n">_main_thread</span><span class="o">.</span><span class="n">_is_stopped</span><span class="p">:</span>
        <span class="c1"># _shutdown() was already called</span>
        <span class="k">return</span>

    <span class="c1"># Main thread</span>
    <span class="n">tlock</span> <span class="o">=</span> <span class="n">_main_thread</span><span class="o">.</span><span class="n">_tstate_lock</span>
    <span class="c1"># The main thread isn't finished yet, so its thread state lock can't have</span>
    <span class="c1"># been released.</span>
    <span class="k">assert</span> <span class="n">tlock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="k">assert</span> <span class="n">tlock</span><span class="o">.</span><span class="n">locked</span><span class="p">()</span>
    <span class="n">tlock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
    <span class="n">_main_thread</span><span class="o">.</span><span class="n">_stop</span><span class="p">()</span>

    <span class="c1"># Join all non-deamon threads</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">_shutdown_locks_lock</span><span class="p">:</span>
            <span class="n">locks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_shutdown_locks</span><span class="p">)</span>
            <span class="n">_shutdown_locks</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">locks</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="k">for</span> <span class="n">lock</span> <span class="ow">in</span> <span class="n">locks</span><span class="p">:</span>
            <span class="c1"># mimick Thread.join()</span>
            <span class="n">lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
            <span class="n">lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

        <span class="c1"># new threads can be spawned while we were waiting for the other</span>
        <span class="c1"># threads to complete</span>


<span class="k">def</span> <span class="nf">main_thread</span><span class="p">():</span>
    <span class="sd">"""Return the main thread object.</span>

<span class="sd">    In normal conditions, the main thread is the thread from which the</span>
<span class="sd">    Python interpreter was started.</span>
<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">_main_thread</span>

<span class="c1"># get thread-local implementation, either from the thread</span>
<span class="c1"># module, or from the python fallback</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">_thread</span> <span class="kn">import</span> <span class="n">_local</span> <span class="k">as</span> <span class="n">local</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">_threading_local</span> <span class="kn">import</span> <span class="n">local</span>


<span class="k">def</span> <span class="nf">_after_fork</span><span class="p">():</span>
    <span class="sd">"""</span>
<span class="sd">    Cleanup threading module state that should not exist after a fork.</span>
<span class="sd">    """</span>
    <span class="c1"># Reset _active_limbo_lock, in case we forked while the lock was held</span>
    <span class="c1"># by another (non-forked) thread.  http://bugs.python.org/issue874900</span>
    <span class="k">global</span> <span class="n">_active_limbo_lock</span><span class="p">,</span> <span class="n">_main_thread</span>
    <span class="k">global</span> <span class="n">_shutdown_locks_lock</span><span class="p">,</span> <span class="n">_shutdown_locks</span>
    <span class="n">_active_limbo_lock</span> <span class="o">=</span> <span class="n">_allocate_lock</span><span class="p">()</span>

    <span class="c1"># fork() only copied the current thread; clear references to others.</span>
    <span class="n">new_active</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">current_thread</span><span class="p">()</span>
    <span class="n">_main_thread</span> <span class="o">=</span> <span class="n">current</span>

    <span class="c1"># reset _shutdown() locks: threads re-register their _tstate_lock below</span>
    <span class="n">_shutdown_locks_lock</span> <span class="o">=</span> <span class="n">_allocate_lock</span><span class="p">()</span>
    <span class="n">_shutdown_locks</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
        <span class="c1"># Dangling thread instances must still have their locks reset,</span>
        <span class="c1"># because someone may join() them.</span>
        <span class="n">threads</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">_enumerate</span><span class="p">())</span>
        <span class="n">threads</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_dangling</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">:</span>
            <span class="c1"># Any lock/condition variable may be currently locked or in an</span>
            <span class="c1"># invalid state, so we reinitialize them.</span>
            <span class="k">if</span> <span class="n">thread</span> <span class="ow">is</span> <span class="n">current</span><span class="p">:</span>
                <span class="c1"># There is only one active thread. We reset the ident to</span>
                <span class="c1"># its new value since it can have changed.</span>
                <span class="n">thread</span><span class="o">.</span><span class="n">_reset_internal_locks</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">ident</span> <span class="o">=</span> <span class="n">get_ident</span><span class="p">()</span>
                <span class="n">thread</span><span class="o">.</span><span class="n">_ident</span> <span class="o">=</span> <span class="n">ident</span>
                <span class="n">new_active</span><span class="p">[</span><span class="n">ident</span><span class="p">]</span> <span class="o">=</span> <span class="n">thread</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># All the others are already stopped.</span>
                <span class="n">thread</span><span class="o">.</span><span class="n">_reset_internal_locks</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">thread</span><span class="o">.</span><span class="n">_stop</span><span class="p">()</span>

        <span class="n">_limbo</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">_active</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">_active</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_active</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">_active</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>


<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">_os</span><span class="p">,</span> <span class="s2">"register_at_fork"</span><span class="p">):</span>
    <span class="n">_os</span><span class="o">.</span><span class="n">register_at_fork</span><span class="p">(</span><span class="n">after_in_child</span><span class="o">=</span><span class="n">_after_fork</span><span class="p">)</span>
</pre></div>
</div>
</div>
<!-- END MAIN BODY OF DOCS ––––––––––––– -->
<!-- Google Analytics -->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-154795830-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-154795830-2');
</script>
<!-- MathJax Config -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>
<!-- End Document
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
</body>
</html>